/*
 * FIWARENGSIV2SpecificationLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package org.fiware.lab.orion.controllers;

import com.fasterxml.jackson.core.JsonProcessingException;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import org.fiware.lab.orion.ApiHelper;
import org.fiware.lab.orion.AuthManager;
import org.fiware.lab.orion.Configuration;
import org.fiware.lab.orion.exceptions.ApiException;
import org.fiware.lab.orion.http.Headers;
import org.fiware.lab.orion.http.client.HttpCallback;
import org.fiware.lab.orion.http.client.HttpClient;
import org.fiware.lab.orion.http.client.HttpContext;
import org.fiware.lab.orion.http.request.HttpRequest;
import org.fiware.lab.orion.http.response.HttpResponse;
import org.fiware.lab.orion.http.response.HttpStringResponse;
import org.fiware.lab.orion.models.NotifyRequest;
import org.fiware.lab.orion.models.Options5Enum;
import org.fiware.lab.orion.models.OptionsEnum;
import org.fiware.lab.orion.models.QueryRequest;
import org.fiware.lab.orion.models.QueryResponse;
import org.fiware.lab.orion.models.UpdateRequest;

/**
 * This class lists all the endpoints of the groups.
 */
public final class BatchOperationsController extends BaseController {

    /**
     * Initializes the controller.
     * @param config    Configurations added in client.
     * @param httpClient    Send HTTP requests and read the responses.
     * @param authManagers    Apply authorization to requests.
     */
    public BatchOperationsController(Configuration config, HttpClient httpClient,
            Map<String, AuthManager> authManagers) {
        super(config, httpClient, authManagers);
    }

    /**
     * Initializes the controller with HTTPCallback.
     * @param config    Configurations added in client.
     * @param httpClient    Send HTTP requests and read the responses.
     * @param authManagers    Apply authorization to requests.
     * @param httpCallback    Callback to be called before and after the HTTP call.
     */
    public BatchOperationsController(Configuration config, HttpClient httpClient,
            Map<String, AuthManager> authManagers, HttpCallback httpCallback) {
        super(config, httpClient, authManagers, httpCallback);
    }

    /**
     * This operation allows to create, update and/or delete several entities in a single batch
     * operation. The payload is an object with two properties: + `actionType`, to specify the kind
     * of update action to do: either `append`, `appendStrict`, `update`, `delete`, or `replace`. +
     * `entities`, an array of entities, each entity specified using the JSON entity representation
     * format (described in the section "JSON Entity Representation"). This operation is split in as
     * many individual operations as entities in the `entities` vector, so the `actionType` is
     * executed for each one of them. Depending on the `actionType`, a mapping with regular
     * non-batch operations can be done: * `append`: maps to `POST /v2/entities` (if the entity does
     * not already exist) or `POST /v2/entities/&lt;id&gt;/attrs` (if the entity already exists). *
     * `appendStrict`: maps to `POST /v2/entities` (if the entity does not already exist) or `POST
     * /v2/entities/&lt;id&gt;/attrs?options=append` (if the entity already exists). * `update`: maps to
     * `PATCH /v2/entities/&lt;id&gt;/attrs`. * `delete`: maps to `DELETE
     * /v2/entities/&lt;id&gt;/attrs/&lt;attrName&gt;` on every attribute included in the entity or to `DELETE
     * /v2/entities/&lt;id&gt;` if no attribute were included in the entity. * `replace`: maps to `PUT
     * /v2/entities/&lt;id&gt;/attrs`. Response: * Successful operation uses 204 No Content. * Errors use
     * a non-2xx and (optionally) an error payload. See subsection on "Error Responses" for more
     * details.
     * @param  body  Required parameter: Example:
     * @param  options  Optional parameter: Options dictionary
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void update(
            final UpdateRequest body,
            final Options5Enum options) throws ApiException, IOException {
        HttpRequest request = buildUpdateRequest(body, options);
        HttpResponse response = getClientInstance().execute(request, false);
        HttpContext context = new HttpContext(request, response);

        handleUpdateResponse(context);
    }

    /**
     * This operation allows to create, update and/or delete several entities in a single batch
     * operation. The payload is an object with two properties: + `actionType`, to specify the kind
     * of update action to do: either `append`, `appendStrict`, `update`, `delete`, or `replace`. +
     * `entities`, an array of entities, each entity specified using the JSON entity representation
     * format (described in the section "JSON Entity Representation"). This operation is split in as
     * many individual operations as entities in the `entities` vector, so the `actionType` is
     * executed for each one of them. Depending on the `actionType`, a mapping with regular
     * non-batch operations can be done: * `append`: maps to `POST /v2/entities` (if the entity does
     * not already exist) or `POST /v2/entities/&lt;id&gt;/attrs` (if the entity already exists). *
     * `appendStrict`: maps to `POST /v2/entities` (if the entity does not already exist) or `POST
     * /v2/entities/&lt;id&gt;/attrs?options=append` (if the entity already exists). * `update`: maps to
     * `PATCH /v2/entities/&lt;id&gt;/attrs`. * `delete`: maps to `DELETE
     * /v2/entities/&lt;id&gt;/attrs/&lt;attrName&gt;` on every attribute included in the entity or to `DELETE
     * /v2/entities/&lt;id&gt;` if no attribute were included in the entity. * `replace`: maps to `PUT
     * /v2/entities/&lt;id&gt;/attrs`. Response: * Successful operation uses 204 No Content. * Errors use
     * a non-2xx and (optionally) an error payload. See subsection on "Error Responses" for more
     * details.
     * @param  body  Required parameter: Example:
     * @param  options  Optional parameter: Options dictionary
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> updateAsync(
            final UpdateRequest body,
            final Options5Enum options) {
        return makeHttpCallAsync(() -> buildUpdateRequest(body, options),
            request -> getClientInstance().executeAsync(request, false),
            context -> handleUpdateResponse(context));
    }

    /**
     * Builds the HttpRequest object for update.
     */
    private HttpRequest buildUpdateRequest(
            final UpdateRequest body,
            final Options5Enum options) throws JsonProcessingException {
        //the base uri for api requests
        String baseUri = config.getBaseUri();

        //prepare query string for API call
        final StringBuilder queryBuilder = new StringBuilder(baseUri
                + "/v2/op/update");

        //load all query parameters
        Map<String, Object> queryParameters = new HashMap<>();
        queryParameters.put("options",
                (options != null) ? options.value() : null);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("Content-Type", "application/json");
        headers.add("user-agent", BaseController.userAgent);

        //prepare and invoke the API call request to fetch the response
        String bodyJson = ApiHelper.serialize(body);
        HttpRequest request = getClientInstance().postBody(queryBuilder, headers, queryParameters,
                bodyJson);

        // Invoke the callback before request if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onBeforeRequest(request);
        }

        return request;
    }

    /**
     * Processes the response for update.
     * @return An object of type void
     */
    private Void handleUpdateResponse(
            HttpContext context) throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onAfterResponse(context);
        }

        //handle errors defined at the API level
        validateResponse(response, context);

        return null;
    }

    /**
     * The response payload is an Array containing one object per matching entity, or an empty array
     * `[]` if no entities are found. The entities follow the JSON entity representation format
     * (described in the section "JSON Entity Representation"). The payload may contain the
     * following elements (all of them optional): + `entities`: a list of entites to search for.
     * Each element is represented by a JSON object with the following elements: + `id` or
     * `idPattern`: Id or pattern of the affected entities. Both cannot be used at the same time,
     * but one of them must be present. + `type` or `typePattern`: Type or type pattern of the
     * entities to search for. Both cannot be used at the same time. If omitted, it means "any
     * entity type". + `attrs`: List of attributes to be provided (if not specified, all
     * attributes). + `expression`: an expression composed of `q`, `mq`, `georel`, `geometry` and
     * `coords` (see "List entities" operation above about this field). + `metadata`: a list of
     * metadata names to include in the response. See "Filtering out attributes and metadata"
     * section for more detail. Response code: * Successful operation uses 200 OK * Errors use a
     * non-2xx and (optionally) an error payload. See subsection on "Error Responses" for more
     * details.
     * @param  body  Required parameter: Example:
     * @param  limit  Optional parameter: Limit the number of entities to be retrieved.
     * @param  offset  Optional parameter: Skip a number of records.
     * @param  orderBy  Optional parameter: Criteria for ordering results. See "Ordering Results"
     *         section for details.
     * @param  options  Optional parameter: Options dictionary
     * @return    Returns the List of QueryResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<QueryResponse> query(
            final QueryRequest body,
            final Double limit,
            final Double offset,
            final String orderBy,
            final OptionsEnum options) throws ApiException, IOException {
        HttpRequest request = buildQueryRequest(body, limit, offset, orderBy, options);
        HttpResponse response = getClientInstance().execute(request, false);
        HttpContext context = new HttpContext(request, response);

        return handleQueryResponse(context);
    }

    /**
     * The response payload is an Array containing one object per matching entity, or an empty array
     * `[]` if no entities are found. The entities follow the JSON entity representation format
     * (described in the section "JSON Entity Representation"). The payload may contain the
     * following elements (all of them optional): + `entities`: a list of entites to search for.
     * Each element is represented by a JSON object with the following elements: + `id` or
     * `idPattern`: Id or pattern of the affected entities. Both cannot be used at the same time,
     * but one of them must be present. + `type` or `typePattern`: Type or type pattern of the
     * entities to search for. Both cannot be used at the same time. If omitted, it means "any
     * entity type". + `attrs`: List of attributes to be provided (if not specified, all
     * attributes). + `expression`: an expression composed of `q`, `mq`, `georel`, `geometry` and
     * `coords` (see "List entities" operation above about this field). + `metadata`: a list of
     * metadata names to include in the response. See "Filtering out attributes and metadata"
     * section for more detail. Response code: * Successful operation uses 200 OK * Errors use a
     * non-2xx and (optionally) an error payload. See subsection on "Error Responses" for more
     * details.
     * @param  body  Required parameter: Example:
     * @param  limit  Optional parameter: Limit the number of entities to be retrieved.
     * @param  offset  Optional parameter: Skip a number of records.
     * @param  orderBy  Optional parameter: Criteria for ordering results. See "Ordering Results"
     *         section for details.
     * @param  options  Optional parameter: Options dictionary
     * @return    Returns the List of QueryResponse response from the API call
     */
    public CompletableFuture<List<QueryResponse>> queryAsync(
            final QueryRequest body,
            final Double limit,
            final Double offset,
            final String orderBy,
            final OptionsEnum options) {
        return makeHttpCallAsync(() -> buildQueryRequest(body, limit, offset, orderBy, options),
            request -> getClientInstance().executeAsync(request, false),
            context -> handleQueryResponse(context));
    }

    /**
     * Builds the HttpRequest object for query.
     */
    private HttpRequest buildQueryRequest(
            final QueryRequest body,
            final Double limit,
            final Double offset,
            final String orderBy,
            final OptionsEnum options) throws JsonProcessingException {
        //the base uri for api requests
        String baseUri = config.getBaseUri();

        //prepare query string for API call
        final StringBuilder queryBuilder = new StringBuilder(baseUri
                + "/v2/op/query");

        //load all query parameters
        Map<String, Object> queryParameters = new HashMap<>();
        queryParameters.put("limit", limit);
        queryParameters.put("offset", offset);
        queryParameters.put("orderBy", orderBy);
        queryParameters.put("options",
                (options != null) ? options.value() : null);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("Content-Type", "application/json");
        headers.add("user-agent", BaseController.userAgent);
        headers.add("accept", "application/json");

        //prepare and invoke the API call request to fetch the response
        String bodyJson = ApiHelper.serialize(body);
        HttpRequest request = getClientInstance().postBody(queryBuilder, headers, queryParameters,
                bodyJson);

        // Invoke the callback before request if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onBeforeRequest(request);
        }

        return request;
    }

    /**
     * Processes the response for query.
     * @return An object of type List of QueryResponse
     */
    private List<QueryResponse> handleQueryResponse(
            HttpContext context) throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onAfterResponse(context);
        }

        //handle errors defined at the API level
        validateResponse(response, context);

        //extract result from the http response
        String responseBody = ((HttpStringResponse) response).getBody();
        List<QueryResponse> result = ApiHelper.deserializeArray(responseBody,
                QueryResponse[].class);
        return result;
    }

    /**
     * This operation is intended to consume a notification payload so that all the entity data
     * included by such notification is persisted, overwriting if necessary. This operation is
     * useful when one NGSIv2 endpoint is subscribed to another NGSIv2 endpoint (federation
     * scenarios). The request payload must be an NGSIv2 notification payload. The behaviour must be
     * exactly the same as `POST /v2/op/update` with `actionType` equal to `append`. Response code:
     * * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload.
     * See subsection on "Error Responses" for more details.
     * @param  body  Required parameter: Example:
     * @param  options  Optional parameter: Options dictionary
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void notify(
            final NotifyRequest body,
            final Options5Enum options) throws ApiException, IOException {
        HttpRequest request = buildNotifyRequest(body, options);
        HttpResponse response = getClientInstance().execute(request, false);
        HttpContext context = new HttpContext(request, response);

        handleNotifyResponse(context);
    }

    /**
     * This operation is intended to consume a notification payload so that all the entity data
     * included by such notification is persisted, overwriting if necessary. This operation is
     * useful when one NGSIv2 endpoint is subscribed to another NGSIv2 endpoint (federation
     * scenarios). The request payload must be an NGSIv2 notification payload. The behaviour must be
     * exactly the same as `POST /v2/op/update` with `actionType` equal to `append`. Response code:
     * * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload.
     * See subsection on "Error Responses" for more details.
     * @param  body  Required parameter: Example:
     * @param  options  Optional parameter: Options dictionary
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> notifyAsync(
            final NotifyRequest body,
            final Options5Enum options) {
        return makeHttpCallAsync(() -> buildNotifyRequest(body, options),
            request -> getClientInstance().executeAsync(request, false),
            context -> handleNotifyResponse(context));
    }

    /**
     * Builds the HttpRequest object for notify.
     */
    private HttpRequest buildNotifyRequest(
            final NotifyRequest body,
            final Options5Enum options) throws JsonProcessingException {
        //the base uri for api requests
        String baseUri = config.getBaseUri();

        //prepare query string for API call
        final StringBuilder queryBuilder = new StringBuilder(baseUri
                + "/v2/op/notify");

        //load all query parameters
        Map<String, Object> queryParameters = new HashMap<>();
        queryParameters.put("options",
                (options != null) ? options.value() : null);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("Content-Type", "application/json");
        headers.add("user-agent", BaseController.userAgent);

        //prepare and invoke the API call request to fetch the response
        String bodyJson = ApiHelper.serialize(body);
        HttpRequest request = getClientInstance().postBody(queryBuilder, headers, queryParameters,
                bodyJson);

        // Invoke the callback before request if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onBeforeRequest(request);
        }

        return request;
    }

    /**
     * Processes the response for notify.
     * @return An object of type void
     */
    private Void handleNotifyResponse(
            HttpContext context) throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onAfterResponse(context);
        }

        //handle errors defined at the API level
        validateResponse(response, context);

        return null;
    }

}