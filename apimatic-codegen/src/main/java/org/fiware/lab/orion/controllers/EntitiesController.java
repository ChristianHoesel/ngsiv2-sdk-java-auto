/*
 * FIWARENGSIV2SpecificationLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package org.fiware.lab.orion.controllers;

import com.fasterxml.jackson.core.JsonProcessingException;
import java.io.IOException;
import java.util.AbstractMap.SimpleEntry;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import org.fiware.lab.orion.ApiHelper;
import org.fiware.lab.orion.AuthManager;
import org.fiware.lab.orion.Configuration;
import org.fiware.lab.orion.exceptions.ApiException;
import org.fiware.lab.orion.http.Headers;
import org.fiware.lab.orion.http.client.HttpCallback;
import org.fiware.lab.orion.http.client.HttpClient;
import org.fiware.lab.orion.http.client.HttpContext;
import org.fiware.lab.orion.http.request.HttpRequest;
import org.fiware.lab.orion.http.response.HttpResponse;
import org.fiware.lab.orion.http.response.HttpStringResponse;
import org.fiware.lab.orion.models.CreateEntityRequest;
import org.fiware.lab.orion.models.ListEntitiesResponse;
import org.fiware.lab.orion.models.Options1Enum;
import org.fiware.lab.orion.models.Options2Enum;
import org.fiware.lab.orion.models.Options4Enum;
import org.fiware.lab.orion.models.Options5Enum;
import org.fiware.lab.orion.models.OptionsEnum;
import org.fiware.lab.orion.models.ReplaceAllEntityAttributesRequest;
import org.fiware.lab.orion.models.RetrieveEntityAttributesResponse;
import org.fiware.lab.orion.models.RetrieveEntityResponse;
import org.fiware.lab.orion.models.UpdateExistingEntityAttributesRequest;
import org.fiware.lab.orion.models.UpdateOrAppendEntityAttributesRequest;

/**
 * This class lists all the endpoints of the groups.
 */
public final class EntitiesController extends BaseController {

    /**
     * Initializes the controller.
     * @param config    Configurations added in client.
     * @param httpClient    Send HTTP requests and read the responses.
     * @param authManagers    Apply authorization to requests.
     */
    public EntitiesController(Configuration config, HttpClient httpClient,
            Map<String, AuthManager> authManagers) {
        super(config, httpClient, authManagers);
    }

    /**
     * Initializes the controller with HTTPCallback.
     * @param config    Configurations added in client.
     * @param httpClient    Send HTTP requests and read the responses.
     * @param authManagers    Apply authorization to requests.
     * @param httpCallback    Callback to be called before and after the HTTP call.
     */
    public EntitiesController(Configuration config, HttpClient httpClient,
            Map<String, AuthManager> authManagers, HttpCallback httpCallback) {
        super(config, httpClient, authManagers, httpCallback);
    }

    /**
     * Retrieves a list of entities that match different criteria by id, type, pattern matching
     * (either id or type) and/or those which match a query or geographical query (see [Simple Query
     * Language](#simple_query_language) and [Geographical Queries](#geographical_queries)). A given
     * entity has to match all the criteria to be retrieved (i.e., the criteria is combined in a
     * logical AND way). Note that pattern matching query parameters are incompatible (i.e. mutually
     * exclusive) with their corresponding exact matching parameters, i.e. `idPattern` with `id` and
     * `typePattern` with `type`. The response payload is an array containing one object per
     * matching entity. Each entity follows the JSON entity representation format (described in
     * "JSON Entity Representation" section). Response code: * Successful operation uses 200 OK *
     * Errors use a non-2xx and (optionally) an error payload. See subsection on "Error Responses"
     * for more details.
     * @param  id  Optional parameter: A comma-separated list of elements. Retrieve entities whose
     *         ID matches one of the elements in the list. Incompatible with `idPattern`.
     * @param  type  Optional parameter: comma-separated list of elements. Retrieve entities whose
     *         type matches one of the elements in the list. Incompatible with `typePattern`.
     * @param  idPattern  Optional parameter: A correctly formated regular expression. Retrieve
     *         entities whose ID matches the regular expression. Incompatible with `id`.
     * @param  typePattern  Optional parameter: A correctly formated regular expression. Retrieve
     *         entities whose type matches the regular expression. Incompatible with `type`.
     * @param  q  Optional parameter: A query expression, composed of a list of statements separated
     *         by `;`, i.e., q=statement1;statement2;statement3. See [Simple Query Language
     *         specification](#simple_query_language).
     * @param  mq  Optional parameter: A query expression for attribute metadata, composed of a list
     *         of statements separated by `;`, i.e., mq=statement1;statement2;statement3. See
     *         [Simple Query Language specification](#simple_query_language).
     * @param  georel  Optional parameter: Spatial relationship between matching entities and a
     *         reference shape. See [Geographical Queries](#geographical_queries).
     * @param  geometry  Optional parameter: Geografical area to which the query is restricted. See
     *         [Geographical Queries](#geographical_queries).
     * @param  coords  Optional parameter: List of latitude-longitude pairs of coordinates separated
     *         by ';'. See [Geographical Queries](#geographical_queries).
     * @param  limit  Optional parameter: Limits the number of entities to be retrieved
     * @param  offset  Optional parameter: Establishes the offset from where entities are retrieved
     * @param  attrs  Optional parameter: Comma-separated list of attribute names whose data are to
     *         be included in the response. The attributes are retrieved in the order specified by
     *         this parameter. If this parameter is not included, the attributes are retrieved in
     *         arbitrary order. See "Filtering out attributes and metadata" section for more detail.
     * @param  metadata  Optional parameter: A list of metadata names to include in the response.
     *         See "Filtering out attributes and metadata" section for more detail.
     * @param  orderBy  Optional parameter: Criteria for ordering results. See "Ordering Results"
     *         section for details.
     * @param  options  Optional parameter: Options dictionary
     * @return    Returns the List of ListEntitiesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<ListEntitiesResponse> listEntities(
            final String id,
            final String type,
            final String idPattern,
            final String typePattern,
            final String q,
            final String mq,
            final String georel,
            final String geometry,
            final String coords,
            final Double limit,
            final Double offset,
            final String attrs,
            final String metadata,
            final String orderBy,
            final OptionsEnum options) throws ApiException, IOException {
        HttpRequest request = buildListEntitiesRequest(id, type, idPattern, typePattern, q, mq,
                georel, geometry, coords, limit, offset, attrs, metadata, orderBy, options);
        HttpResponse response = getClientInstance().execute(request, false);
        HttpContext context = new HttpContext(request, response);

        return handleListEntitiesResponse(context);
    }

    /**
     * Retrieves a list of entities that match different criteria by id, type, pattern matching
     * (either id or type) and/or those which match a query or geographical query (see [Simple Query
     * Language](#simple_query_language) and [Geographical Queries](#geographical_queries)). A given
     * entity has to match all the criteria to be retrieved (i.e., the criteria is combined in a
     * logical AND way). Note that pattern matching query parameters are incompatible (i.e. mutually
     * exclusive) with their corresponding exact matching parameters, i.e. `idPattern` with `id` and
     * `typePattern` with `type`. The response payload is an array containing one object per
     * matching entity. Each entity follows the JSON entity representation format (described in
     * "JSON Entity Representation" section). Response code: * Successful operation uses 200 OK *
     * Errors use a non-2xx and (optionally) an error payload. See subsection on "Error Responses"
     * for more details.
     * @param  id  Optional parameter: A comma-separated list of elements. Retrieve entities whose
     *         ID matches one of the elements in the list. Incompatible with `idPattern`.
     * @param  type  Optional parameter: comma-separated list of elements. Retrieve entities whose
     *         type matches one of the elements in the list. Incompatible with `typePattern`.
     * @param  idPattern  Optional parameter: A correctly formated regular expression. Retrieve
     *         entities whose ID matches the regular expression. Incompatible with `id`.
     * @param  typePattern  Optional parameter: A correctly formated regular expression. Retrieve
     *         entities whose type matches the regular expression. Incompatible with `type`.
     * @param  q  Optional parameter: A query expression, composed of a list of statements separated
     *         by `;`, i.e., q=statement1;statement2;statement3. See [Simple Query Language
     *         specification](#simple_query_language).
     * @param  mq  Optional parameter: A query expression for attribute metadata, composed of a list
     *         of statements separated by `;`, i.e., mq=statement1;statement2;statement3. See
     *         [Simple Query Language specification](#simple_query_language).
     * @param  georel  Optional parameter: Spatial relationship between matching entities and a
     *         reference shape. See [Geographical Queries](#geographical_queries).
     * @param  geometry  Optional parameter: Geografical area to which the query is restricted. See
     *         [Geographical Queries](#geographical_queries).
     * @param  coords  Optional parameter: List of latitude-longitude pairs of coordinates separated
     *         by ';'. See [Geographical Queries](#geographical_queries).
     * @param  limit  Optional parameter: Limits the number of entities to be retrieved
     * @param  offset  Optional parameter: Establishes the offset from where entities are retrieved
     * @param  attrs  Optional parameter: Comma-separated list of attribute names whose data are to
     *         be included in the response. The attributes are retrieved in the order specified by
     *         this parameter. If this parameter is not included, the attributes are retrieved in
     *         arbitrary order. See "Filtering out attributes and metadata" section for more detail.
     * @param  metadata  Optional parameter: A list of metadata names to include in the response.
     *         See "Filtering out attributes and metadata" section for more detail.
     * @param  orderBy  Optional parameter: Criteria for ordering results. See "Ordering Results"
     *         section for details.
     * @param  options  Optional parameter: Options dictionary
     * @return    Returns the List of ListEntitiesResponse response from the API call
     */
    public CompletableFuture<List<ListEntitiesResponse>> listEntitiesAsync(
            final String id,
            final String type,
            final String idPattern,
            final String typePattern,
            final String q,
            final String mq,
            final String georel,
            final String geometry,
            final String coords,
            final Double limit,
            final Double offset,
            final String attrs,
            final String metadata,
            final String orderBy,
            final OptionsEnum options) {
        return makeHttpCallAsync(() -> buildListEntitiesRequest(id, type, idPattern, typePattern, q,
                mq, georel, geometry, coords, limit, offset, attrs, metadata, orderBy, options),
            request -> getClientInstance().executeAsync(request, false),
            context -> handleListEntitiesResponse(context));
    }

    /**
     * Builds the HttpRequest object for listEntities.
     */
    private HttpRequest buildListEntitiesRequest(
            final String id,
            final String type,
            final String idPattern,
            final String typePattern,
            final String q,
            final String mq,
            final String georel,
            final String geometry,
            final String coords,
            final Double limit,
            final Double offset,
            final String attrs,
            final String metadata,
            final String orderBy,
            final OptionsEnum options) {
        //the base uri for api requests
        String baseUri = config.getBaseUri();

        //prepare query string for API call
        final StringBuilder queryBuilder = new StringBuilder(baseUri
                + "/v2/entities");

        //load all query parameters
        Map<String, Object> queryParameters = new HashMap<>();
        queryParameters.put("id", id);
        queryParameters.put("type", type);
        queryParameters.put("idPattern", idPattern);
        queryParameters.put("typePattern", typePattern);
        queryParameters.put("q", q);
        queryParameters.put("mq", mq);
        queryParameters.put("georel", georel);
        queryParameters.put("geometry", geometry);
        queryParameters.put("coords", coords);
        queryParameters.put("limit", limit);
        queryParameters.put("offset", offset);
        queryParameters.put("attrs", attrs);
        queryParameters.put("metadata", metadata);
        queryParameters.put("orderBy", orderBy);
        queryParameters.put("options",
                (options != null) ? options.value() : null);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("user-agent", BaseController.userAgent);
        headers.add("accept", "application/json");

        //prepare and invoke the API call request to fetch the response
        HttpRequest request = getClientInstance().get(queryBuilder, headers, queryParameters,
                null);

        // Invoke the callback before request if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onBeforeRequest(request);
        }

        return request;
    }

    /**
     * Processes the response for listEntities.
     * @return An object of type List of ListEntitiesResponse
     */
    private List<ListEntitiesResponse> handleListEntitiesResponse(
            HttpContext context) throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onAfterResponse(context);
        }

        //handle errors defined at the API level
        validateResponse(response, context);

        //extract result from the http response
        String responseBody = ((HttpStringResponse) response).getBody();
        List<ListEntitiesResponse> result = ApiHelper.deserializeArray(responseBody,
                ListEntitiesResponse[].class);
        return result;
    }

    /**
     * The payload is an object representing the entity to be created. The object follows the JSON
     * entity representation format (described in a "JSON Entity Representation" section). Response:
     * * Successful operation uses 201 Created (if upsert option is not used) or 204 No Content (if
     * upsert option is used). Response includes a `Location` header with the URL of the created
     * entity. * Errors use a non-2xx and (optionally) an error payload. See subsection on "Error
     * Responses" for more details.
     * @param  body  Required parameter: Example:
     * @param  options  Optional parameter: Options dictionary
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void createEntity(
            final CreateEntityRequest body,
            final Options1Enum options) throws ApiException, IOException {
        HttpRequest request = buildCreateEntityRequest(body, options);
        HttpResponse response = getClientInstance().execute(request, false);
        HttpContext context = new HttpContext(request, response);

        handleCreateEntityResponse(context);
    }

    /**
     * The payload is an object representing the entity to be created. The object follows the JSON
     * entity representation format (described in a "JSON Entity Representation" section). Response:
     * * Successful operation uses 201 Created (if upsert option is not used) or 204 No Content (if
     * upsert option is used). Response includes a `Location` header with the URL of the created
     * entity. * Errors use a non-2xx and (optionally) an error payload. See subsection on "Error
     * Responses" for more details.
     * @param  body  Required parameter: Example:
     * @param  options  Optional parameter: Options dictionary
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> createEntityAsync(
            final CreateEntityRequest body,
            final Options1Enum options) {
        return makeHttpCallAsync(() -> buildCreateEntityRequest(body, options),
            request -> getClientInstance().executeAsync(request, false),
            context -> handleCreateEntityResponse(context));
    }

    /**
     * Builds the HttpRequest object for createEntity.
     */
    private HttpRequest buildCreateEntityRequest(
            final CreateEntityRequest body,
            final Options1Enum options) throws JsonProcessingException {
        //the base uri for api requests
        String baseUri = config.getBaseUri();

        //prepare query string for API call
        final StringBuilder queryBuilder = new StringBuilder(baseUri
                + "/v2/entities");

        //load all query parameters
        Map<String, Object> queryParameters = new HashMap<>();
        queryParameters.put("options",
                (options != null) ? options.value() : null);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("Content-Type", "application/json");
        headers.add("user-agent", BaseController.userAgent);

        //prepare and invoke the API call request to fetch the response
        String bodyJson = ApiHelper.serialize(body);
        HttpRequest request = getClientInstance().postBody(queryBuilder, headers, queryParameters,
                bodyJson);

        // Invoke the callback before request if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onBeforeRequest(request);
        }

        return request;
    }

    /**
     * Processes the response for createEntity.
     * @return An object of type void
     */
    private Void handleCreateEntityResponse(
            HttpContext context) throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onAfterResponse(context);
        }

        //handle errors defined at the API level
        validateResponse(response, context);

        return null;
    }

    /**
     * The response is an object representing the entity identified by the ID. The object follows
     * the JSON entity representation format (described in "JSON Entity Representation" section).
     * This operation must return one entity element only, but there may be more than one entity
     * with the same ID (e.g. entities with same ID but different types). In such case, an error
     * message is returned, with the HTTP status code set to 409 Conflict. Response: * Successful
     * operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See
     * subsection on "Error Responses" for more details.
     * @param  entityId  Required parameter: Id of the entity to be retrieved
     * @param  type  Optional parameter: Entity type, to avoid ambiguity in case there are several
     *         entities with the same entity id.
     * @param  attrs  Optional parameter: Comma-separated list of attribute names whose data must be
     *         included in the response. The attributes are retrieved in the order specified by this
     *         parameter. See "Filtering out attributes and metadata" section for more detail. If
     *         this parameter is not included, the attributes are retrieved in arbitrary order, and
     *         all the attributes of the entity are included in the response.
     * @param  metadata  Optional parameter: A list of metadata names to include in the response.
     *         See "Filtering out attributes and metadata" section for more detail.
     * @param  options  Optional parameter: Options dictionary
     * @return    Returns the RetrieveEntityResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public RetrieveEntityResponse retrieveEntity(
            final String entityId,
            final String type,
            final String attrs,
            final String metadata,
            final Options2Enum options) throws ApiException, IOException {
        HttpRequest request = buildRetrieveEntityRequest(entityId, type, attrs, metadata, options);
        HttpResponse response = getClientInstance().execute(request, false);
        HttpContext context = new HttpContext(request, response);

        return handleRetrieveEntityResponse(context);
    }

    /**
     * The response is an object representing the entity identified by the ID. The object follows
     * the JSON entity representation format (described in "JSON Entity Representation" section).
     * This operation must return one entity element only, but there may be more than one entity
     * with the same ID (e.g. entities with same ID but different types). In such case, an error
     * message is returned, with the HTTP status code set to 409 Conflict. Response: * Successful
     * operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See
     * subsection on "Error Responses" for more details.
     * @param  entityId  Required parameter: Id of the entity to be retrieved
     * @param  type  Optional parameter: Entity type, to avoid ambiguity in case there are several
     *         entities with the same entity id.
     * @param  attrs  Optional parameter: Comma-separated list of attribute names whose data must be
     *         included in the response. The attributes are retrieved in the order specified by this
     *         parameter. See "Filtering out attributes and metadata" section for more detail. If
     *         this parameter is not included, the attributes are retrieved in arbitrary order, and
     *         all the attributes of the entity are included in the response.
     * @param  metadata  Optional parameter: A list of metadata names to include in the response.
     *         See "Filtering out attributes and metadata" section for more detail.
     * @param  options  Optional parameter: Options dictionary
     * @return    Returns the RetrieveEntityResponse response from the API call
     */
    public CompletableFuture<RetrieveEntityResponse> retrieveEntityAsync(
            final String entityId,
            final String type,
            final String attrs,
            final String metadata,
            final Options2Enum options) {
        return makeHttpCallAsync(() -> buildRetrieveEntityRequest(entityId, type, attrs, metadata,
                options),
            request -> getClientInstance().executeAsync(request, false),
            context -> handleRetrieveEntityResponse(context));
    }

    /**
     * Builds the HttpRequest object for retrieveEntity.
     */
    private HttpRequest buildRetrieveEntityRequest(
            final String entityId,
            final String type,
            final String attrs,
            final String metadata,
            final Options2Enum options) {
        //the base uri for api requests
        String baseUri = config.getBaseUri();

        //prepare query string for API call
        final StringBuilder queryBuilder = new StringBuilder(baseUri
                + "/v2/entities/{entityId}");

        //process template parameters
        Map<String, SimpleEntry<Object, Boolean>> templateParameters = new HashMap<>();
        templateParameters.put("entityId",
                new SimpleEntry<Object, Boolean>(entityId, true));
        ApiHelper.appendUrlWithTemplateParameters(queryBuilder, templateParameters);

        //load all query parameters
        Map<String, Object> queryParameters = new HashMap<>();
        queryParameters.put("type", type);
        queryParameters.put("attrs", attrs);
        queryParameters.put("metadata", metadata);
        queryParameters.put("options",
                (options != null) ? options.value() : null);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("user-agent", BaseController.userAgent);
        headers.add("accept", "application/json");

        //prepare and invoke the API call request to fetch the response
        HttpRequest request = getClientInstance().get(queryBuilder, headers, queryParameters,
                null);

        // Invoke the callback before request if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onBeforeRequest(request);
        }

        return request;
    }

    /**
     * Processes the response for retrieveEntity.
     * @return An object of type RetrieveEntityResponse
     */
    private RetrieveEntityResponse handleRetrieveEntityResponse(
            HttpContext context) throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onAfterResponse(context);
        }

        //handle errors defined at the API level
        validateResponse(response, context);

        //extract result from the http response
        String responseBody = ((HttpStringResponse) response).getBody();
        RetrieveEntityResponse result = ApiHelper.deserialize(responseBody,
                RetrieveEntityResponse.class);

        return result;
    }

    /**
     * This request is similar to retreiving the whole entity, however this one omits the `id` and
     * `type` fields. Just like the general request of getting an entire entity, this operation must
     * return only one entity element. If more than one entity with the same ID is found (e.g.
     * entities with same ID but different type), an error message is returned, with the HTTP status
     * code set to 409 Conflict. Response: * Successful operation uses 200 OK * Errors use a non-2xx
     * and (optionally) an error payload. See subsection on "Error Responses" for more details.
     * @param  entityId  Required parameter: Id of the entity to be retrieved
     * @param  type  Optional parameter: Entity type, to avoid ambiguity in case there are several
     *         entities with the same entity id.
     * @param  attrs  Optional parameter: Comma-separated list of attribute names whose data are to
     *         be included in the response. The attributes are retrieved in the order specified by
     *         this parameter. If this parameter is not included, the attributes are retrieved in
     *         arbitrary order, and all the attributes of the entity are included in the response.
     *         See "Filtering out attributes and metadata" section for more detail.
     * @param  metadata  Optional parameter: A list of metadata names to include in the response.
     *         See "Filtering out attributes and metadata" section for more detail.
     * @param  options  Optional parameter: Options dictionary
     * @return    Returns the RetrieveEntityAttributesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public RetrieveEntityAttributesResponse retrieveEntityAttributes(
            final String entityId,
            final String type,
            final String attrs,
            final String metadata,
            final Options2Enum options) throws ApiException, IOException {
        HttpRequest request = buildRetrieveEntityAttributesRequest(entityId, type, attrs, metadata,
                options);
        HttpResponse response = getClientInstance().execute(request, false);
        HttpContext context = new HttpContext(request, response);

        return handleRetrieveEntityAttributesResponse(context);
    }

    /**
     * This request is similar to retreiving the whole entity, however this one omits the `id` and
     * `type` fields. Just like the general request of getting an entire entity, this operation must
     * return only one entity element. If more than one entity with the same ID is found (e.g.
     * entities with same ID but different type), an error message is returned, with the HTTP status
     * code set to 409 Conflict. Response: * Successful operation uses 200 OK * Errors use a non-2xx
     * and (optionally) an error payload. See subsection on "Error Responses" for more details.
     * @param  entityId  Required parameter: Id of the entity to be retrieved
     * @param  type  Optional parameter: Entity type, to avoid ambiguity in case there are several
     *         entities with the same entity id.
     * @param  attrs  Optional parameter: Comma-separated list of attribute names whose data are to
     *         be included in the response. The attributes are retrieved in the order specified by
     *         this parameter. If this parameter is not included, the attributes are retrieved in
     *         arbitrary order, and all the attributes of the entity are included in the response.
     *         See "Filtering out attributes and metadata" section for more detail.
     * @param  metadata  Optional parameter: A list of metadata names to include in the response.
     *         See "Filtering out attributes and metadata" section for more detail.
     * @param  options  Optional parameter: Options dictionary
     * @return    Returns the RetrieveEntityAttributesResponse response from the API call
     */
    public CompletableFuture<RetrieveEntityAttributesResponse> retrieveEntityAttributesAsync(
            final String entityId,
            final String type,
            final String attrs,
            final String metadata,
            final Options2Enum options) {
        return makeHttpCallAsync(() -> buildRetrieveEntityAttributesRequest(entityId, type, attrs,
                metadata, options),
            request -> getClientInstance().executeAsync(request, false),
            context -> handleRetrieveEntityAttributesResponse(context));
    }

    /**
     * Builds the HttpRequest object for retrieveEntityAttributes.
     */
    private HttpRequest buildRetrieveEntityAttributesRequest(
            final String entityId,
            final String type,
            final String attrs,
            final String metadata,
            final Options2Enum options) {
        //the base uri for api requests
        String baseUri = config.getBaseUri();

        //prepare query string for API call
        final StringBuilder queryBuilder = new StringBuilder(baseUri
                + "/v2/entities/{entityId}/attrs");

        //process template parameters
        Map<String, SimpleEntry<Object, Boolean>> templateParameters = new HashMap<>();
        templateParameters.put("entityId",
                new SimpleEntry<Object, Boolean>(entityId, true));
        ApiHelper.appendUrlWithTemplateParameters(queryBuilder, templateParameters);

        //load all query parameters
        Map<String, Object> queryParameters = new HashMap<>();
        queryParameters.put("type", type);
        queryParameters.put("attrs", attrs);
        queryParameters.put("metadata", metadata);
        queryParameters.put("options",
                (options != null) ? options.value() : null);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("user-agent", BaseController.userAgent);
        headers.add("accept", "application/json");

        //prepare and invoke the API call request to fetch the response
        HttpRequest request = getClientInstance().get(queryBuilder, headers, queryParameters,
                null);

        // Invoke the callback before request if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onBeforeRequest(request);
        }

        return request;
    }

    /**
     * Processes the response for retrieveEntityAttributes.
     * @return An object of type RetrieveEntityAttributesResponse
     */
    private RetrieveEntityAttributesResponse handleRetrieveEntityAttributesResponse(
            HttpContext context) throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onAfterResponse(context);
        }

        //handle errors defined at the API level
        validateResponse(response, context);

        //extract result from the http response
        String responseBody = ((HttpStringResponse) response).getBody();
        RetrieveEntityAttributesResponse result = ApiHelper.deserialize(responseBody,
                RetrieveEntityAttributesResponse.class);

        return result;
    }

    /**
     * The request payload is an object representing the attributes to append or update. The object
     * follows the JSON entity representation format (described in "JSON Entity Representation"
     * section), except that `id` and `type` are not allowed. The entity attributes are updated with
     * the ones in the payload, depending on whether the `append` operation option is used or not. *
     * If `append` is not used: the entity attributes are updated (if they previously exist) or
     * appended (if they don't previously exist) with the ones in the payload. * If `append` is used
     * (i.e. strict append semantics): all the attributes in the payload not previously existing in
     * the entity are appended. In addition to that, in case some of the attributes in the payload
     * already exist in the entity, an error is returned. Response: * Successful operation uses 204
     * No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on "Error
     * Responses" for more details.
     * @param  entityId  Required parameter: Entity id to be updated
     * @param  body  Required parameter: Example:
     * @param  type  Optional parameter: Entity type, to avoid ambiguity in case there are several
     *         entities with the same entity id.
     * @param  options  Optional parameter: Operations options
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void updateOrAppendEntityAttributes(
            final String entityId,
            final UpdateOrAppendEntityAttributesRequest body,
            final String type,
            final Options4Enum options) throws ApiException, IOException {
        HttpRequest request = buildUpdateOrAppendEntityAttributesRequest(entityId, body, type,
                options);
        HttpResponse response = getClientInstance().execute(request, false);
        HttpContext context = new HttpContext(request, response);

        handleUpdateOrAppendEntityAttributesResponse(context);
    }

    /**
     * The request payload is an object representing the attributes to append or update. The object
     * follows the JSON entity representation format (described in "JSON Entity Representation"
     * section), except that `id` and `type` are not allowed. The entity attributes are updated with
     * the ones in the payload, depending on whether the `append` operation option is used or not. *
     * If `append` is not used: the entity attributes are updated (if they previously exist) or
     * appended (if they don't previously exist) with the ones in the payload. * If `append` is used
     * (i.e. strict append semantics): all the attributes in the payload not previously existing in
     * the entity are appended. In addition to that, in case some of the attributes in the payload
     * already exist in the entity, an error is returned. Response: * Successful operation uses 204
     * No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on "Error
     * Responses" for more details.
     * @param  entityId  Required parameter: Entity id to be updated
     * @param  body  Required parameter: Example:
     * @param  type  Optional parameter: Entity type, to avoid ambiguity in case there are several
     *         entities with the same entity id.
     * @param  options  Optional parameter: Operations options
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> updateOrAppendEntityAttributesAsync(
            final String entityId,
            final UpdateOrAppendEntityAttributesRequest body,
            final String type,
            final Options4Enum options) {
        return makeHttpCallAsync(() -> buildUpdateOrAppendEntityAttributesRequest(entityId, body,
                type, options),
            request -> getClientInstance().executeAsync(request, false),
            context -> handleUpdateOrAppendEntityAttributesResponse(context));
    }

    /**
     * Builds the HttpRequest object for updateOrAppendEntityAttributes.
     */
    private HttpRequest buildUpdateOrAppendEntityAttributesRequest(
            final String entityId,
            final UpdateOrAppendEntityAttributesRequest body,
            final String type,
            final Options4Enum options) throws JsonProcessingException {
        //the base uri for api requests
        String baseUri = config.getBaseUri();

        //prepare query string for API call
        final StringBuilder queryBuilder = new StringBuilder(baseUri
                + "/v2/entities/{entityId}/attrs");

        //process template parameters
        Map<String, SimpleEntry<Object, Boolean>> templateParameters = new HashMap<>();
        templateParameters.put("entityId",
                new SimpleEntry<Object, Boolean>(entityId, true));
        ApiHelper.appendUrlWithTemplateParameters(queryBuilder, templateParameters);

        //load all query parameters
        Map<String, Object> queryParameters = new HashMap<>();
        queryParameters.put("type", type);
        queryParameters.put("options",
                (options != null) ? options.value() : null);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("Content-Type", "application/json");
        headers.add("user-agent", BaseController.userAgent);

        //prepare and invoke the API call request to fetch the response
        String bodyJson = ApiHelper.serialize(body);
        HttpRequest request = getClientInstance().postBody(queryBuilder, headers, queryParameters,
                bodyJson);

        // Invoke the callback before request if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onBeforeRequest(request);
        }

        return request;
    }

    /**
     * Processes the response for updateOrAppendEntityAttributes.
     * @return An object of type void
     */
    private Void handleUpdateOrAppendEntityAttributesResponse(
            HttpContext context) throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onAfterResponse(context);
        }

        //handle errors defined at the API level
        validateResponse(response, context);

        return null;
    }

    /**
     * The request payload is an object representing the attributes to update. The object follows
     * the JSON entity representation format (described in "JSON Entity Representation" section),
     * except that `id` and `type` are not allowed. The entity attributes are updated with the ones
     * in the payload. In addition to that, if one or more attributes in the payload doesn't exist
     * in the entity, an error is returned. Response: * Successful operation uses 204 No Content *
     * Errors use a non-2xx and (optionally) an error payload. See subsection on "Error Responses"
     * for more details.
     * @param  entityId  Required parameter: Id of the entity to be updated
     * @param  body  Required parameter: Example:
     * @param  type  Optional parameter: Entity type, to avoid ambiguity in case there are several
     *         entities with the same entity id.
     * @param  options  Optional parameter: Operations options
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void updateExistingEntityAttributes(
            final String entityId,
            final UpdateExistingEntityAttributesRequest body,
            final String type,
            final Options5Enum options) throws ApiException, IOException {
        HttpRequest request = buildUpdateExistingEntityAttributesRequest(entityId, body, type,
                options);
        HttpResponse response = getClientInstance().execute(request, false);
        HttpContext context = new HttpContext(request, response);

        handleUpdateExistingEntityAttributesResponse(context);
    }

    /**
     * The request payload is an object representing the attributes to update. The object follows
     * the JSON entity representation format (described in "JSON Entity Representation" section),
     * except that `id` and `type` are not allowed. The entity attributes are updated with the ones
     * in the payload. In addition to that, if one or more attributes in the payload doesn't exist
     * in the entity, an error is returned. Response: * Successful operation uses 204 No Content *
     * Errors use a non-2xx and (optionally) an error payload. See subsection on "Error Responses"
     * for more details.
     * @param  entityId  Required parameter: Id of the entity to be updated
     * @param  body  Required parameter: Example:
     * @param  type  Optional parameter: Entity type, to avoid ambiguity in case there are several
     *         entities with the same entity id.
     * @param  options  Optional parameter: Operations options
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> updateExistingEntityAttributesAsync(
            final String entityId,
            final UpdateExistingEntityAttributesRequest body,
            final String type,
            final Options5Enum options) {
        return makeHttpCallAsync(() -> buildUpdateExistingEntityAttributesRequest(entityId, body,
                type, options),
            request -> getClientInstance().executeAsync(request, false),
            context -> handleUpdateExistingEntityAttributesResponse(context));
    }

    /**
     * Builds the HttpRequest object for updateExistingEntityAttributes.
     */
    private HttpRequest buildUpdateExistingEntityAttributesRequest(
            final String entityId,
            final UpdateExistingEntityAttributesRequest body,
            final String type,
            final Options5Enum options) throws JsonProcessingException {
        //the base uri for api requests
        String baseUri = config.getBaseUri();

        //prepare query string for API call
        final StringBuilder queryBuilder = new StringBuilder(baseUri
                + "/v2/entities/{entityId}/attrs");

        //process template parameters
        Map<String, SimpleEntry<Object, Boolean>> templateParameters = new HashMap<>();
        templateParameters.put("entityId",
                new SimpleEntry<Object, Boolean>(entityId, true));
        ApiHelper.appendUrlWithTemplateParameters(queryBuilder, templateParameters);

        //load all query parameters
        Map<String, Object> queryParameters = new HashMap<>();
        queryParameters.put("type", type);
        queryParameters.put("options",
                (options != null) ? options.value() : null);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("Content-Type", "application/json");
        headers.add("user-agent", BaseController.userAgent);

        //prepare and invoke the API call request to fetch the response
        String bodyJson = ApiHelper.serialize(body);
        HttpRequest request = getClientInstance().patchBody(queryBuilder, headers, queryParameters,
                bodyJson);

        // Invoke the callback before request if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onBeforeRequest(request);
        }

        return request;
    }

    /**
     * Processes the response for updateExistingEntityAttributes.
     * @return An object of type void
     */
    private Void handleUpdateExistingEntityAttributesResponse(
            HttpContext context) throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onAfterResponse(context);
        }

        //handle errors defined at the API level
        validateResponse(response, context);

        return null;
    }

    /**
     * The request payload is an object representing the new entity attributes. The object follows
     * the JSON entity representation format (described in a "JSON Entity Representation" above),
     * except that `id` and `type` are not allowed. The attributes previously existing in the entity
     * are removed and replaced by the ones in the request. Response: * Successful operation uses
     * 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on
     * "Error Responses" for more details.
     * @param  entityId  Required parameter: Id of the entity in question.
     * @param  body  Required parameter: Example:
     * @param  type  Optional parameter: Entity type, to avoid ambiguity in case there are several
     *         entities with the same entity id.
     * @param  options  Optional parameter: Operations options
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void replaceAllEntityAttributes(
            final String entityId,
            final ReplaceAllEntityAttributesRequest body,
            final String type,
            final Options5Enum options) throws ApiException, IOException {
        HttpRequest request = buildReplaceAllEntityAttributesRequest(entityId, body, type, options);
        HttpResponse response = getClientInstance().execute(request, false);
        HttpContext context = new HttpContext(request, response);

        handleReplaceAllEntityAttributesResponse(context);
    }

    /**
     * The request payload is an object representing the new entity attributes. The object follows
     * the JSON entity representation format (described in a "JSON Entity Representation" above),
     * except that `id` and `type` are not allowed. The attributes previously existing in the entity
     * are removed and replaced by the ones in the request. Response: * Successful operation uses
     * 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on
     * "Error Responses" for more details.
     * @param  entityId  Required parameter: Id of the entity in question.
     * @param  body  Required parameter: Example:
     * @param  type  Optional parameter: Entity type, to avoid ambiguity in case there are several
     *         entities with the same entity id.
     * @param  options  Optional parameter: Operations options
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> replaceAllEntityAttributesAsync(
            final String entityId,
            final ReplaceAllEntityAttributesRequest body,
            final String type,
            final Options5Enum options) {
        return makeHttpCallAsync(() -> buildReplaceAllEntityAttributesRequest(entityId, body, type,
                options),
            request -> getClientInstance().executeAsync(request, false),
            context -> handleReplaceAllEntityAttributesResponse(context));
    }

    /**
     * Builds the HttpRequest object for replaceAllEntityAttributes.
     */
    private HttpRequest buildReplaceAllEntityAttributesRequest(
            final String entityId,
            final ReplaceAllEntityAttributesRequest body,
            final String type,
            final Options5Enum options) throws JsonProcessingException {
        //the base uri for api requests
        String baseUri = config.getBaseUri();

        //prepare query string for API call
        final StringBuilder queryBuilder = new StringBuilder(baseUri
                + "/v2/entities/{entityId}/attrs");

        //process template parameters
        Map<String, SimpleEntry<Object, Boolean>> templateParameters = new HashMap<>();
        templateParameters.put("entityId",
                new SimpleEntry<Object, Boolean>(entityId, true));
        ApiHelper.appendUrlWithTemplateParameters(queryBuilder, templateParameters);

        //load all query parameters
        Map<String, Object> queryParameters = new HashMap<>();
        queryParameters.put("type", type);
        queryParameters.put("options",
                (options != null) ? options.value() : null);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("Content-Type", "application/json");
        headers.add("user-agent", BaseController.userAgent);

        //prepare and invoke the API call request to fetch the response
        String bodyJson = ApiHelper.serialize(body);
        HttpRequest request = getClientInstance().putBody(queryBuilder, headers, queryParameters,
                bodyJson);

        // Invoke the callback before request if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onBeforeRequest(request);
        }

        return request;
    }

    /**
     * Processes the response for replaceAllEntityAttributes.
     * @return An object of type void
     */
    private Void handleReplaceAllEntityAttributesResponse(
            HttpContext context) throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onAfterResponse(context);
        }

        //handle errors defined at the API level
        validateResponse(response, context);

        return null;
    }

    /**
     * Delete the entity. Response: * Successful operation uses 204 No Content * Errors use a
     * non-2xx and (optionally) an error payload. See subsection on "Error Responses" for more
     * details.
     * @param  entityId  Required parameter: Id of the entity to be deleted
     * @param  type  Optional parameter: Entity type, to avoid ambiguity in case there are several
     *         entities with the same entity id.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void removeEntity(
            final String entityId,
            final String type) throws ApiException, IOException {
        HttpRequest request = buildRemoveEntityRequest(entityId, type);
        HttpResponse response = getClientInstance().execute(request, false);
        HttpContext context = new HttpContext(request, response);

        handleRemoveEntityResponse(context);
    }

    /**
     * Delete the entity. Response: * Successful operation uses 204 No Content * Errors use a
     * non-2xx and (optionally) an error payload. See subsection on "Error Responses" for more
     * details.
     * @param  entityId  Required parameter: Id of the entity to be deleted
     * @param  type  Optional parameter: Entity type, to avoid ambiguity in case there are several
     *         entities with the same entity id.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> removeEntityAsync(
            final String entityId,
            final String type) {
        return makeHttpCallAsync(() -> buildRemoveEntityRequest(entityId, type),
            request -> getClientInstance().executeAsync(request, false),
            context -> handleRemoveEntityResponse(context));
    }

    /**
     * Builds the HttpRequest object for removeEntity.
     */
    private HttpRequest buildRemoveEntityRequest(
            final String entityId,
            final String type) {
        //the base uri for api requests
        String baseUri = config.getBaseUri();

        //prepare query string for API call
        final StringBuilder queryBuilder = new StringBuilder(baseUri
                + "/v2/entities/{entityId}");

        //process template parameters
        Map<String, SimpleEntry<Object, Boolean>> templateParameters = new HashMap<>();
        templateParameters.put("entityId",
                new SimpleEntry<Object, Boolean>(entityId, true));
        ApiHelper.appendUrlWithTemplateParameters(queryBuilder, templateParameters);

        //load all query parameters
        Map<String, Object> queryParameters = new HashMap<>();
        queryParameters.put("type", type);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("user-agent", BaseController.userAgent);

        //prepare and invoke the API call request to fetch the response
        HttpRequest request = getClientInstance().delete(queryBuilder, headers, queryParameters,
                null);

        // Invoke the callback before request if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onBeforeRequest(request);
        }

        return request;
    }

    /**
     * Processes the response for removeEntity.
     * @return An object of type void
     */
    private Void handleRemoveEntityResponse(
            HttpContext context) throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onAfterResponse(context);
        }

        //handle errors defined at the API level
        validateResponse(response, context);

        return null;
    }

}